Dependency Inversion Prensibi
Injection yöntemin ismi, presip değildir.
* S.O.L.I.D.'in presipleri

Bu prensipin esprisi mevcut proje kodlarımızı yazarken; üst seviyedeki modul'ler ya da class'lar alt seviyedeki modul veya class'lara
bağımlı olmasın. Eğer iki tane modulümüz varsa bunlar birbirlerine bağımlı olmak yerine bir soyut arayüz üzerinden bağımlı olsunlar
bunu söylüyor.

S.O.L.I.D'in D'sini konuşurken yani dependency inversion'u; daha üst seviyedeki modul'ler, üst seviyedeki class'lar daha alt seviyedeki
class'lara ya da modul'lere direk olarak bağımlı olmasınlar. Bunlar birbirleri içerisinde kullanılacaklardır ama bu kullanımı yapmak
soyut bir arayüz üzerinden gerçekleştirilsin ama direk bağlı olmasınlar, bu prensip'in ismi dependency inversion.
Mesela bizim activity class'ımızda içinde bir şeyler kullanıcam başka class'lara ihtiyaç duyucam bu prensip bana diyor ki:
eğer senin tepedeki daha üstteki yapın activity ise içindeki diğer kullanacağın class'lar activity'den daha low level class'larsa
ki kullanacağımız neredeyse hepsi öyle class'lar. Bu durumda bu activity o class'lardan mümkün olduğunca bağımsız hareket edebilsin.
O class'ların impelantaston detayları, nasıl oluşturuldukları bu class'ın içerisinden bir yerde yer almasın. Temel prensip temel dert
bu. İlla bir bapımlılık gerekecekse ki gerekecek bu gereksinimi mümkünse soyut bir arayüz üzerinden yapalım. Yine ilgili gereksinim
sınıfın içerisinde net bir şekilde bulunmasın.

* Inversion of control : Yazılım geliştirme süreçlerinde bir nesnenin nasıl oluşturulacağını veya nasıl bir işlem gerçekleştireceği
gibi işleri / kontrolleri nesnenin kendisinden alarak kontrolü başka bir yapıya devredilmesi işlemidir.

Coupling-Cohesion
Tightly coupling / losely coupling
Eğer ki bir sınıf başka bir sınıfın nesnesine ihtiyaç duyuyorsa kendi içinde. Bu durumda bu iki nesnenin nasıl oluşturulacağına bağlı
olarak bu iki sınıfın birbirine sıkı sıkıya ya da daha gevşek bağlı olduğuna dair kanıya variyoruz.
Diyelim ki elimde main activity sınıfı var ve analitik kütüphanesinin nesnesini oluşturmam gerekiyor eğer bu nesne oluştuma işlemini
ben direk class'ın içerisinde yapıyorsam bu durumda bu 2 class birbirine sıkı sıkıya bağlı demek oluyor. Bazen bu istenilen bir şey
de olabilir ama genel yazacağımız kodlarda bu bir problemdir. Mümkün olduğunda her bir sınıf diğer başka bir sınıfa olabildiğince
gevşek bir şekilde bağlı olsun çünkü kullanıcağımız yapılar değişecek.
Mesela dataroid bir analitik kütüphanesi firebase'in,netmera'nın çeşitli çeşitli bu iş için kullanılabilecek sektörde envai çeşit
analitik kütüphanesi var. Bir gün gelecek product owner'ınız netmera ile anlaştık diyecek. Jr şöyle düşünür: ben gideyim netmera'nın
dökümantasyonuna bakayım implemantasyonu yapayım sonra da gelip kullanayım. Biraz daha işi bilen Sr şöyle düşünür: benim bir analitik
yapısına ihtiyacım var o zaman ben bu analitik yapısını soyut bir şekilde oluşturayım ana uygulamanın kendisinden bağımsız olarak.
Bunun içerisine bugün için netmera koyayım implementasyon için gerekli fonksiyonların arayüzünü çıkarayım ve uygulamamda bu arayüzleri
koyayım kullanayım. Sonrasında farklı bir analitik kütüphaneye geçildiğinde sizin bu sefer yapmanız gereken sadece şey o analitik
arayüzünde netmera'yı kaldırıp yenisini koymak ve yenisinin fonksiyonlarını kendi arayüzünüzde olacak şekilde yedirmek. Dolayısıyla
activity'lerde kullandığımız yerlerde değişiklik yapmayız sadece arayüzde değişiklik yaparız.
Cohesion
Bir class'ın başka bir class'a sıkı sıkıya bağlı olması cohesion'un düşmesine neden oluyor.
Cohesion: bir sınıfın ya da bir modulün be kadar iyi tanımlanmış kendi işlevine ne kadar iyi odaklandığını ifade eder.
Yüksek cohesion: bir sınıfın tek bir sorumluluğu olması ve tek o sorumluluğu yerine getirmesini ifade ediyor.
Mesela main activity'de onCreate'in cohesion'unun yüksek mi düşük mü olduğuna nasıl kara vericem?
Şöyle düşünmemiz gerekiyor: bir activity'in onCreate'inin sorumluluğu ne o ekranı çizdirmek ama biz gelip bazı classların nesnelerini de
burda oluşturup işlem yapıyorsak artı olarak yüklediğimiz görevle birlikte cohesion düşmüş olur. Çünkü fonksiyon temel sorumluluğunun
dışında iş yapmış oluyor.

** İş görüşmesinde sorulur: neden di olarak dagger'ı hilt'i koin'i bir tool'u kullanırız? Kullanmasaydık nolurdu? Herhangi bir di tool'u
kullanmadan manuel olarak di nasıl yaparız?
Di'ı manuel olarak da yapabiliyorduk, manuel olarak yapmanın bu class'lara library'lere dezavantajları var. O dezavantajlarla uğraşmamak
için bunu harici kütüphanelere devrediyoruz.

--emrenin podcastleri

Modern bir android projesinde di'ı en temelde nerelerde kullanıyoruz?
activity ve fragment'larımız olcak,bunlarla beraber çalışan viewmodellerimiz olacak
bu viewmodeller repository'lerle konuşucak, bu repositoler ya local db ya da uzak sunucuya gidicek

SON 1SA BAKILIR

-------------------------------------------------

Ders11

Bazı sınıflar constructor inject edilemeyen sınıflardır. Mesela interface'ler, abstract class'lar ya da bazı sınıflarımız var sistem tarafınfan
yönetilen. Örnek olarak app ayağa kalkarken ekranda ilk gözüken activity'imizin nesnesini oluşturmuyoruz, jetpack navigation kullanıyorsak
diğer activity veya fragment'ların da nesnesini oluşturmuyoruz sistem ya da ilgili kütüphaneler tarafından bizlere veriliyor. Bu gibi sistem
tarafından yönetilen sınıflar da yine constructor'ı inject edilemeyen sınıflardır. Veya kullanmak istediğimiz sınıf veya arayüz 3th parti bir
kütüphanenin sınıf veya arayüzüdür, zaten onu biz editleyebilecek durumda da değilizdir. Bu gibi durumlara constructor injection'a kapalı
sınıflar ya da interface'ler diyeceğiz. Dolayısıyla mesela activity class'ımız constructor injection'a kapalı olduğu için bizim activity'de
kullanacağımız dependency'imiz viewmodel'dı. Viewmodel'i constructor inject şeklinde yapamıyorsak geriye ne kalmış oluyor o zaman field injection
yapmamız lazım.
Ama bu kullanımlarda gereksiz boilerplate kod tekrarlarına düşmemize sebep oluyor. Bu sefer de bunun yerine çözüm olarak;
AppContainer isimli bir class oluşturalım. Bu sınıfın içine de hem activity'deki kullandığımız yönetmeye çalıştığımız hem de başka sınıflar
tarafından da kullanılabilecek olan tüm dependency'leri / bağımlılıkları ilgili AppContainer'ın içerisine koyayım. Bu bize ne sağlayacak?
Normal mesela uzak sunucu için gerekli olan retrofit nesnesini ana ekranımda oluşturup kullandığım gibi başka bir ekranda da gerekecek ve
yine oluşturup kullanma durumuna düşücem. AppContainer içerisinde dependency'ler bulundurarak başka bir sınıfa geçtiğinizde de yine aynı
retrofit nesnesini kullanabilirsiniz. Zaten AppConntainer'de oluşturmuştunuz. Dolayısıyla objelerin tekrardan kullanımını da doğru bir şekilde
yönetmiş oluyoruz, önceki kullanımda mesela activity class'ı içinde retrofit nesnesi oluşturmadan kullanmamız her ekranda bu nesneyi oluşturmadan
kullanma hatasını alabiliriz ama AppContainer içine koyunca sıralama en falza bi kere yanlış olur geri düzeltilmesi de çabuk olur, ayrıca
activity class'larımızdaki boilerplate kod'lardan da kurtulmuş oluruz.
Peki AppContainer ile nasıl kullanıyoruz projelerimizde?
Bu AppContainer sınıfını her mobil uygulamanın application sınıfı var. Manifest'te Launcher olarak tanımlanan activity ne ise app'in ikona
tıklayınca ilk ayağa kalkan activity o. Aslında bu activity sınıfından hemen önce bizim bir Application sınıfımız oluyor. Bu illa yazmak
zorunda olduğunuuz bir sınıf değil. İsterseniz Application sınıfından miras alan kendi application sınıfınızı yazabilirsiniz. Bunu yazdığınızda
bu tüm activity'lerden launcher activity'de dahil önce çalışan bir sınıfınız oluyor. Aynı zamanda Application sınıfının kendisi de bir context.
Ve tüm activity'ler fragment'lar tarafından da bu Application sınıfına erişebiliyorsunuz. Dolayısıyla AppConatiner ile dependecy yönetimi yapmak
istiyorsak, diğer tüm sınıflarımızın kullanacağı dependency'lerimizi tek bir sınıf üzerinde toplamak istiyorsak, bu sınıfa diğer her sınıftan
erişim verebiliyor olmanız lazım. Yani activity'lerimin tamamı bu AppContainer sınıfının nesnesine hızlı ve kolay bir şekilde erişebilmesi
lazım ya da fragment'ların ya da view class'ların. Dolayısıyla bu AppContainer sınıfı benim kendi oluşturduğum Application sınıfımın bir nesnesi
şeklinde tutulursa dolayısıyla application sınıfına activity'den,fragment'ten,başka custom view sınıfından erişebilicem. Dolayısıyla her yerden
AppContainer nesnesine erişebilirim. Erişimden sonra da AppContainer'ın içerisinde olan dependency'leri ilgili olarak gerektiği yerde çağırıp
kullanabilirim.
Yani bu yöntemle de sonucumuz; bütün bağımlılıkları tek bir sınıfta yönet, yönettiğin bu sınıfı diğer tüm sınıflara görünür kıl.
*Kendi application class'ımızın içinde appcontainer nesnesi oluşturarak yaptığımız şey yapısal olarak singleton değil. AppContainer'ı object
olarak değil düz bir class olarak yazıyoruz. Ama bu sıradan class'ın instance'ı application sınıfının içerisinde olduğu için tüm uygulama
tarafından tüketilebilir oluyor. Bunun mümkün olduğunca az yapmanız lazım çünkü singleton pattern aynı zamanda anti pattern olarak da
isimlendirilirdi bunun sebebi de memory'de garbage collector tarafından silinemeyen alanlar inşa etmiş oluyorduk. Dolayısıyla bundan çok fazla
yapmamız da memory'i aşırı şekilde dolduruyordu ve bize günün sonunda autofmemory bir hatayla karşılık verecektir. Biz burda di yönetirken
singleton pattern kullanmıyoruz ama yapısı gereği Application sınıfı uygulamanın lifecycle'ı boyunca ayakta kaldığını düşündüğümüz bir class
dolayısıyla içinde kullandığımız değişken de singleton olmasa bile memory'de application sınıfı ayakta kaldığı sürece bulunacak. Dolayısıyla
nerdeyse singleton kadar bize sıkıntılı bir ortam sunmuş oluyor. Ama burda singleton'la şöyle bir fark var; singleton garbage collector tarafından
temizlenemiyor ama Application sınıfı uygulamanın lifecycle'ı boyunca ayakta durduğu memory'de yer kapladığı süre boyunca kesin olarak ayakta
kalacağının bir garantisi yok, garbage collector çok zorda kaldığı durumlarda application sınıfı da temizleyebiliyor. O yüzde application
sınıfları hiç silinemeyen bir yapıda değil.

Bu AppContainer ile olan yapıdaki sorunumuz da; biz mesela login activity'deyiz o activity ekranı geçmek için gerekli repository'e ihtiyacımız
var, onu da AppContainer sınıfı içinde değişken olarak tutulan nesnesini çağırarak alıyoruz. Ama login activity'i geçtikten sonra benim ilgili
o repository'e bir daha ihtiyacım yok gittimiz fragment veya activity'in kendi repository'leri gerekli, onlar da zaten AppContainer sınıfının
içerisinde bulunacaklar zaten. Dolayısıyla üzerine düşününce AppContainer de bize şöyle problemler getiriyor:
1- AppContainer sınıfı çok büyüyecek demek oluyor bu. Çünkü bütün bağımlılıklarımı burdan yönetiyorum. Daha sonrasında bakımı zorlaşacak.
2- AppContainer'ın uygulama lifecycle'ı boyunca yer kaplaması da mesela şöyle problem getirecek. Mesela AppContainer sınıfımın içerisinde
    300-400tane dependency varsa uygulama daha ayağa kalkarken kullanıcı o ekranlara girecek ya da girmeyecek bilmiyoruz bile ama
    dependency'lerini oluşturduk bile. Bu yüzden de uygulama ayağa kalkar kalkmaz kocaman bir memory alanını işgal ettim. Ve bu memory alanı biz
    ekstra bir yönetimde bulunmazsak uygulama lifecycle'ı boyunca da değişmiyor. Bu çok kötü bir memory yönetimine neden oluyor.

Bu yüzden de bizim bu AppContainer sınıfını da memory kullanımına göre optimize etmemiz lazım.
AppContainer içerisinde yer kaplayan dependency'lerin lifecycle'ı ne olucak. Buraya şöyle bir şey dememiz lazım: bu AppContainer sınfının bir
kısmı loginActivity'de çalışacak bir kısmı sadece dashboard'de çalışacak bir kısmı sadece profile'de çalışacak gibi benim bu AppContainer
sınıfını parçalayabiliyor olmam lazım. Dolayısıyla AppContainer sınıfınızı farklı usecase'lerinize göre bölmeniz lazım. Mesela LoginConatiner
sınfı oluşturursunuz AppContainer'ın bir parçası olarak bu sınıf sadece login'le ilgili viewmodel'i repository'leri o ekran için gerekli
dependency'leri içeriyor olur. Bundan sonra LoginContainer,DashboardContainer,ProfileContainer gibi sadece ilgili fonksiyonlara göre child
container'ler oluşturuyorsunuz. Ve bu child container'ların direk olarak nesnesini oluşturmuyorsunuz AppContainer sınıfı içinde, bunları nullable
şekilde tutuyoruz. Neden nullable tutuyoruz?
Çünkü ilgili container'lar direk olarak nesnesi oluşturulursa en başta yaşadığımız probleme dönüyoruz. Bu nullable child container'ları ne zaman
kullanılacaklarsa o zaman doldurmam lazım. Dolayısıyla ana container'ımızı(AppContainer) parçaladık küçük container'lara böldük. Ve bu küçük
container'ları da hangi usecase'lerde hangi ekranlarda kullanacaksınız o ekranlarda nesnelerini oluşturuyorsunuz. Ve daha sonra bu ekrandan
çıkarken sonuçta bu nesne AppContainer içerisinde tutulmaya devam edilecek ve bu application lifecycle'ı boyunca uygulamada yer kaplayacak
sonrasında bu ekrandan da çıkarken ilgili child container'ınızı null'lamanız gerekiyor. Bu şekilde login'e girdin login'in container'ını oluştur
login'den çıktın container'ı null'a eşitle,dashboard'a geldin container'ını oluştur dashboard'dan başka ekrana geçtin dashboard'ın container'ını
boşalt.Bu şekilde bir akışla giderek dependency'lerimiz container'lar tarafından artık AppContainer hala başta tüm container'ların yönetimi onun
içerisinde bulunuyor, parçaladığımız için yönetimi kolay, memory objesi olarak da hepsini tutmuyoruz ne zaman ki ilgli fonksiyonlara gidiyorsak
ancak o zaman ilgili child container'ı oluşturuyoruz ilgili fonksiyondan da çıkarken ilgili child container'ı null'luyoruz.

İsterseniz son haliyle böyle dependency injection yönetimini sağlatabilirsiniz. En son halinde memory management'ını da düzelttik, bütün
dependency'leri tek bir yerde ama onun child'ları olacak şekilde yönetimi kolay bir şekle getirdik. Ve böyle kullanmaya devam edebiliriz.

Ama android tüm bu yaptığımız işlemleri arka planda yapan kütüphaneler inşa ettik zaten diyor. Bunun bir tanesi dagger-hilt bir tanesi koin.
Farklı pattern'leri kullanıyorlar arka planda bir tanesi dependency injection kullanırken bir tanesi service-locater-pattern kullanıyor. Biri
build süresi kısmında bu yaptığın işlemleri generate ederken biri sen bunu runtime'da istediğin durumda generate edecek. Bunun gibi farklı
özellikler içeren kütüphaneler zaten hazırlanmış durumda.

Bu manuel olarak yönettiğimiz işi aoutomated olarak kütüphanelere bırakarak burda çözümler ikiye ayrılıyor: biri reflection based dediğimiz
çözümler var runtime sırasında gerçekleşiyor bunlar dependencyleri runtime sırasında veriyor bize, bir de build time de generate edilen classlar
yardımıyla bu işi çözen yöntemler var. İlk yöntem çok fazla kullanılmıyor runtime'da reflection based çözen yöntemler falza kullanılmıyor.
Çünkü reflection kullandığınızda, eğer reflection kullanarak bir class'ın instance'ını oluşturuyor ya da fonksiyonlarına erişiyorsanız hem
performans olarak sıkıntılı hem de proguard gibi ofustike işlemlere yol açan classların,fonksiyonların isimlerini dönüştüren yapılar
kullanıyorsanız da bu reflection'a engel oluyordu. Proguard ile yapılan iş reflection'ı etkilediğinden reflection'a ekstra rule'lar koymanız
gerekiyordu.
Compile time dediğimizde dagger ve hilt çözümleri var. Burda siz build işlemi sırasında run tuşuna bastığınız anda yaptığınız setup'a göre
kullandığınız dependency'ler arka planda ilgili class'lara generate ediliyor. Ve bu generate edilen class'lar yardımıyla ilgili dependency'leri
yönetiyoruz. Bir de bunlara alternatif olarak service-locater dediğimiz bir patern var. Bu pattern'de AppContainer yapısında olduğu gibi aslında
biz o bütün dependency'leri tek bir sınıf yardımıyla çözüyoruz ve bu sınıf runtime da ihtiyaç duyulduğu anda bize ilgili dependency'leri veriyor.
Yani buil time sırasında bir generate işlemi yapmıyor, runtime da sanki reflection based çözüm gibi runtime sırasında ilgili dependency'leri
veren bir pattern.
* Mid'e doğru giderken sorulabilir. Koin vs Hilt farkları nelerdir?
En temeldeki fark bu arka planda kullandıkları pattern'ler. Eğer hilt'i dagger'ı kullanıyorsak bildiğiniz anlamda generation veya annotation based
bir dependency injection kullanmış oluyoruz. Build time'da generate edilen class'lar yardımıyla yapıyor bunu. Koin dediğimiz şeyse builtime'da
ekstra bir şey yapmıyor runtime'da size bu dependency'leri veriyor ama bu dependency'leri verirken de kullandığı pattern'de servie-locater isimli
bir pattern. Bu iki yöntem arasındaki temel farklar bizim nasıl sonuçlara ulaşmamıza neden oluyor?
Hali hazırda bir build problemimiz varsa yani hazırdaki projemizde build süresi çok fazlaysa bir de bu projeye hilt'i eklersek bu süre daha
dramatik bir şekilde artacak. Dolayısıyla hazırdaki build süresi problemi olan projede belki koin'i tercih edebilirsiniz. Koin'i tercih ettiğiniz
durumda da bu sefer bu dependency yönetimi build işlemi sırasında ekstra bir işlem yapmadığı için eğer dependency yönetiminizde bir problem varsa
bunu o dependency'in runtime'da çalıştığı sırada haberdar oluyorsunuz. Bu size test edilebilirlik kısmında biraz zorluk çıkartıyor. Yeterli unit
testleriniz, ui testleriniz yoksa yeterli sayıda iyi test uzmanı ekiplerle çalışmıyorsanız böyle bir yerde koin ile çalışmak görece riskli
olabilir.

HILT IMPLEMANTASYONU
Step 1 -> project gradle dosyamıza geliyoruz plugin kısmına hilt-android plugin'i koyucaz.
          id("com.google.dagger.hilt.android") version "2.44" apply false

Step 2 -> hangi gradle module'lere sahipsek onlara gradle module olan app module'imize geliyoruz bunun plugin kısmına hangi module'leri
          kullanacağımızı yazıyoruz.
          id("kotlin-kapt")
          id("com.google.dagger.hilt.android")

Step 3 -> ilgili kütüphaneleri dependency'lerimize ekliyoruz
          implementation("com.google.dagger:hilt-android:2.44")
          kapt("com.google.dagger:hilt-android-compiler:2.44")

Step 4 -> Sync Now

Step 5 -> kapt'ın şöyle bir konfigürasyonu var gradle module'e eklenmeli. Bunun anlamı kapt ile beraber projede kodlarımızı kullanırken arka
          planda bazı şeylerin generate edildiğini söyleyeceğiz.Generate edilirken oluşturulan class'lar da java class'lar. Dolayısıyla arkada
          bu java class'ları generate edilirken bazen kullandığımız type'ların ne olduğunu tam olarak doğru şekilde generate edemeyebiliyor hilt
          ya da kapt. correctErrorTypes dediğimizde yapabildiği kadar bu tipleri düzeltiyor, düzeltemediklerinin de error vermesini engelliyor.
          Yine biz o haliyle de çalışabiliyoruz ama eğer buna true demezseniz kotlin'de daha fazla build time da hata alma ihtimaliniz olacak.
          Aslında o generate edilen java'daki hali projede kullanabiliyoruz da build işlemi sırasındaki keskin kurallarda normalde bunu demeseniz
          ya aslında bunun tipini tam olarak anlamıyorum diyip hilt bize uyarı vericek. O yüzden bunu diyerek ordaki hatalardan biraz daha
          kurtulmuş olucaksınız.
          kapt {
            correctErrorTypes = true
          }
Temel entegrasyonlarımız bu kadar.

Bunların versiyonlarının aynı olması gerekiyor! Eğer plugin'de 2.44 kullandıysanız dependency kısmında da aynısı olmalı.

Hilt'i ve kapt'ı kullandığınız diğer yöntemleri mesela databinding gibi yöntemleri de android studio'nun 4.0 ve üstü sürümlerinde
kullanabiliyorsunuz. Daha altındaki bir versionda kullanıyorsanız hata alacaksınız.

Project plugin'ler niye varlar?
Biz run tuşuna bastığımızda eğer build sırasında bir şeyler yapılacaksa o yapılan şeyler çoğunlukla plugin'ler tarafından yönetiliyor.
Bilin ki plugin sizin build sürenizde muhtemelen run tuşuna bastığımızda geçecek olan o compile time'da çok yüksek ihtimalle arka planda bir
şeyler yapacak. O yüzden bir plugin kullanmamız gerekiyor hilt için de. Çünkü arka planda generate edilen şeyleri olacak.

kapt (kotlin annotaion processing tool) : Bu eğer annotation based tabanlı bir işlem yapacaksanız bir çalışma yöntemi benimsiyorsanız. İşte
hilt için annotation based bir yapımız var, room db için annotation based bir yapımız var, retrofit için annotation based bir kullanımımız var.
Bu gibi kütüphaneleri, bunlardan herhangi birini kullanıyorsanız ilgili kütüphanenin kapt dependency'sini de ve kapt plugin'inini de projenize
eklemeniz gerekiyor. kapt'ın yerine geçecek olan ksp denilen bir yapımız daha var. Artık kotlin kapt ksp'ye doğru dönüştürülüyor.
* kapt yerine ksp 2x kadar daha hızlı build.

* hilt arka planda java 1.8 feature'larını kullanıor arka planda kodları generate ederken ya da yapması gereken işlemleri yaparken. O yüzden
1.8 ve üzerini kullandığınızdan emin olun modeule gradle'da!

* compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
Module gradle'daki bu yapılar nedir ne işe yararlar?
sourceCompatibility = hangi java sürümüyle projenizin derlendiğini, yazıldığını söylüyoruz. Kendi kaynak kodlarımızın hangi java versiyonuyla
                      yazıldığıdır.
targetCompatibility = derleyicinin üreteceği bytecode'ların hangi jvm sürümünde çalışacağını söylüyoruz. Hangi jvm sürümünde çalıştıracağımızdır.

* Module gradle'da targetSdk ve compileSdk nedirler?

hilt'i 2.44'de bırakırsaniz android gradle plugin (agp) ile çakışıyor bu sefer de. agp 8.0.0 üzerini kullanıyorsanız hilt versiyonu 2.44'ün
üzerine çekmeniz lazım.

Hilt arka planda bir şeyleri generate edecek.Kullandığımız bu dependency'leri de bu generate ettiğimiz class'lar yardımıyla alıcaz. O halde bu
generation işleminin bir başlangıç noktası olması lazım. Biz run tuşuna bastığımızda bir kod tetiklenecek ondan sonra da projedeki diğer bütün
dependency'lerimin derlenebiliyor olması lazım. Bu yüzden de hilt bize projelerimizde bir application sınıfı açmamızı istiyor manuel dependency
injection son kısımlarında AppContainer'de olduğu gibi. Bu sınıfın da Application sınıfından miras alması lazım. Bunu oluşturduktan sonra da
manifeste şu bilgiyi vermemiz gerekiyor: benim bir tane application sınıfım var ve bu application sınıfını uygulama ayağa kalkarken kullanmak
istiyorum. Manisfest'te application tag'i altına android:name="com.abdulkadirkara.kekod_di.MyApp"
Şimdi de bu MyApp class'ını bir annotation yardımıyla hilt bizim projemizde generation işlemlerine başlayabiliyor olacak. O annotation da
@HiltAndroidApp'dir.
Application sınıfımıza bu annotation'u koyduktan sonra Project görünümüne geçip -> app -> build -> generated -> source -> kapt ->
hangi build variant'ta çalışıyorsanız (biz şu an debug mod'da çalışıyoruz) ona uygun olan kapt'ın kısmına geliyorsunuz burda ->
sırayla package ismine göre (bizde com -> abdulkadirkara -> kekod_di) içerisinde -> MyApp_GeneratedInjector isimli bir sınıf görüyoruz.
Hilt bize kullandığımız application sınıfına bağlantığını ordaki generate edilen kodla söylemiş oluyor.

@OriginatingElement(
    topLevelClass = MyApp.class
)
@GeneratedEntryPoint
@InstallIn(SingletonComponent.class)
public interface MyApp_GeneratedInjector {
  void injectMyApp(MyApp myApp);
}

Şu an bilinmesi gereken kısım: Benim hilt'i kullanabilmem için kod genertion işlemlerinin başlayabilmesi için App sınıfıma mutlaka
@HiltAndroidApp annotasyonunu vermem lazım. Bunu verdikten sonra projemde hilt aktif edilmiş olacak. Hilt artık gerekli dependency'leri
gerekli sınıflara ilgili android sınıflarına verebilir hale geliyor. Hilt'in desteklediği bu android sınıfları dediğimiz şeyler sınıflar
en başta application sınıfı, viewmodel sınıflarımız, activity ve fragment'larımız, custom yazığımız view sınıflarını, broadcast
receiver'ları, yazacağımız servisleri yönetebiliyor olacağız. Bu sınıflar hilt'in android sınıfları olarak geçiyorlar. Bu android
sınıflarına denk gelen çeşitli hilt'in android component sınıfları var. O component sınıfları yardımıyla çözebiliyor olacağız.
Dikkat edilmesi gereken bir kısım olarak: eğer activity'lerde hilt'i kullanıyor olacaksanız miras aldığınız sınıfın mutlaka
ComponentActivity'den ya da bunun altındaki diğer child activity'lerin birinden miras alması gerekiyor, aynı şekilde fragment'larla
çalışmaya başladığınızda androidx ile olan versiyonu kullanmıyorsak yine bunda da hata alırız hilt ile çalışırken. retainFragment'lar
ile de hilt çalışamıyor, eğer projenizde bir fragment retainInstance'a sahipse o fragment'ınızda da hilt'in çalışmayacağını bilin.
retain Fragment'ın esprisi: konfigürasyon değişikliği yaptığımızda bu fragment'ın instance'ının saklanmasını sağlatmış oluyoruz.
Ekstra olarak saveInstanceState ve restoreInstanceState gibi şeylerle uğraşmıyorduk.

Activity'lerle hilt'i çalıştırabilmemiz için hilt injection'larımızı yapabilmemiz için bu activity class'ımızın da başına
@AndroidEntryPoint annotation'ununu yazıyoruz. Bu annotation'la beraber activity'imize bu component sınıfları kullanabilir, bunun
içerisideki dependency'leri kullanabilir hale geliyorsunuz. Bunu yaptığınızda artık constructor injection ya da field injection'ları
kullanabilirsiniz.
Bizim constructor injection'ı kullanabilmemiz için bir yerde nesnesini oluşturma val main = MainActivity() gibi yazmamız lazım ki bunun
constructor'ını çağırdığımızı söyleyelim. Bunu biz kendimiz yapmadığımız için zaten launcher aktivitemiz, harici ikinci bir aktivitemiz
olsaydı jetpack navigation ile yönetiyorsak yine SecondActivity() gibi constructor'ını kullanmadığımız için bu durumlarda constructor
injection'ı aktivitelerde yapmıyoruz. Aktivitelerde kullanabileceğimiz geriye bir tek yöntem kalıyor field injection.
Field injection yaparken de hilt bize şöyle diyor: @Inject annotation'ı kullan. Bunun için şöyle bir kurgu yapalım AnaylticsAdapter
class'ı main activity'de inject etme üzerine.
AnalyticsAdapter bizden bir service bekliyor. Bu service bir interface olucak ve body'siz metodu olucak. Şimdi dependency injection
kullanmadığımız durumda service'in içindeki analyticsMethods() metodu nasıl tetikleyecektim?

Hilt'le ilgili projede bir hata alıyorsan bakman gereken 2-3 yer var
agp, kotlin versiyonu, hilt plugin versiyonu(project gradle'daki),dependency versiyonun
bu dördünün birbiriyle uyumlu olduğunu garanti etmeniz gerekiyor.
Mesela ide'de hilt size kotlin versiyonuyla ilgili bir hata verecek örneğin 1.0'dan büyük olsun gibi baktınız kotlin versiyonunda bir
problem yok ilk bakmanız gereken yer hilt'in bu versiyonu kotlin'in bu versiyonuyla uyumlu mu olabilir. Uyumlu ve çalışabiliyor olarak
gördüyseniz de ikinci olarak agp versiyonuyla uyumlu çalışıyor mu ona bakmanız gerekiyor. Eğer agp ile uyumlu değilse ya agp versiyonu
düşürmenüz gerekiyor ya da hilt versiyonu yükseltmeniz. 2.44'te bu hata ile karşılaşırsınız hilt'te bu sürümü en az 2.48'e çekerseniz
hatanın giderildiğini görüceksiniz.

* mülakat sorusu
constructor inject edilmeyen bir sınıfa ben nasıl hilt'e söyleyerek onu dependency olarak kullanabilirim?
interface için kullanıyorsak @Binds yöntemiyle module'ler oluşturup ilgili module'lere nerde kullanıcaksak activity'se ona göre fragment ise ona
göre @InstallIn içinde hilt component'i yazıp sonrasında da bu module sınıfını tanımlayıp içerisine de abstract olarak da ilgili interface'i
implemente ettiğim class'ı parametre olarak verip geri dönüşüne interface'i alacağım abstract functionlar yazarım. Bu sayede hilt bana ilgili
interface'i inject edebilir. Retrofit gibi kütüphane class'ları için de @Provides diye bir annotation var.

** eğer mülakatta zorlamak isterse şöyle sorabilir.
Mesela retrofit'i kullanıyorsun onun interceptor'ları var. İşte iki tane retrofit intstance'ı beklediğini varsayalım. Biri loglama interceptor'una
sahip olsun diğeri de sahip olmasın. bu durumda bu iki retrofit instance'ını nasıl yönetirsin?

** annotation bilgisinden ziyade;
neden biz di diye bir şey kullanıyoruz?
bunun arkasında atan prensip ne?
bana bir tane usecase söyle kullanmazsak ne gibi bir problem yaşarız?
gibi sorular daha anlamlı. Sen bu soruları bilirsen gerisi implemantasyon detayı öğrenmesi kolaydır.

**module'de neden abstract fonksiyonlar tanımlıyoruz?
Çünkü fonk body'sini hilt dolduracak.

field inject olan adapter'ın sınıfında constructor inject'in içine bir de LogAdapter oluşturup ınu eklersek tek hata verir hilt yine.
Çünkü bu log nesnesini nasıl üretileceğini söylemediğimiz için. Dolayısıyla bu LogAdapter'ın sınıfına da constructor injection yapmamız lazım.

--------------------------------------------------------------

Ders12

dependency inversion = high level modul ve class'ların low level class ve modul'lere depend olmasın bağımlı olmasın. İşin yapılış şekilnde üst
level'ler alt levele bu kadar bağımlı olurlarsa kendilerine kendi başlarına yapacakları işler için sürekli onların kopyasını bulundurmaları
gerekir. Bu birliktelik bağımlılık durumuna tightly couple losely couple diyoruz. Tightly ya da losely olmasını ne sağlıyordu? Eğer bir sınıf
kendi sınırları scope'u içerisinde diğer low level bir sınıfın instance'ını barındırıyorsa burda tightly couple durumu var diyoruz. Tightl couple
dezavantajı olarak eğer o sınıfa bir test case yazmak isterseniz low level'in instance'ını mock'layamıyorsunuz. Mock'lamak dediğimiz şey de bu
low level class instance'ını üretirken o sınıfa dair de testler yazmanız lazım. Yani sizin high level class'ınızı doğru şekilde test edebilmeniz
için low level'in de farklı varyasyonlarına ihtiyacınız olacak ama bu sınıfı high level class'ın içine aldığımızda mocklama şansımız olmuyor
artık. Yani bu sınıfın içerdeki kullanımı neyse artık sadece onu test edebiliyorsunuz bu da test yapma yeteneklerinizi oldukça zayıflatıyor.
Bu yüzden tightly couple test yeteneklerinizi oldukça zayıflatıyor, ikincisi tghtly couple olan class'lar low leveldeki sınıfların farklı
varyasyonları ihtiyaç olduğunda çok fazla yerin değiştirilmesine neden oluyor.
Coupled olan sınıflarda bir de cohesion kavramından bahsetmiştik.
Sınıf ve moduller için cohesion: Eğer bir sınıf,fonksiyon,module sadece kendisinden sorumlu olan işi yapıyorsa burda cohesion yüksek diyorduk.
Eğer tightly sınıflara baktığımızda birden fazla görevleri olmuş oluyor.

Şimdi biz kotlinde hilt'te ve öğreneceğimiz daha ilerdeki bir çok projede annotation'lar üzerinden bir çalışma yapıcaz. Dolayısıyla bu tarz
annotation'lar üzerinden giden çalışmalarda kapt'ı kullanmanız lazım. kapt hilt'e özel bir konu değil room db ile de çalışırken retrofitle
çalışırken de kapt'a ihtiyaç duyacağız. kapt aslında android sisteminde kotlin sisteminde annotaiton ile çalışıyorsanız eğer annotaionlar ile
çalıştığınız her yerde ihtiyaç duyduğunuz bir yapı. Bu yüzden hilt ile de çalışırken hilt'in kendi compiler'ını kapt'a vermeniz lazım
dependencies kısmında module gradle'da.

** kapt vs ksp

Biz application sınıflarıyla beraber activity sınıflarından da önce belli şeyler generate edilsin ve kullanılsın istiyorsak bu custom
application sınıfına ihtiyaç duyacağız. Birçok 3th parti sdk kendi initialize başlatma işlemini application'ın onCreate'inin içerisinde
yapılmasını isteyecek sizden, offical dökümanasyonlarını okuduğunuzda orda yapılmasını isteyecekler.
**Application sınıfı uygulamanın lifecycle'ı boyunca arka planda bulunduğu dönemi de katıyorum bunun içerisine sürekli olarak kesin olarak
memory'de yer kaplayan ve kesin olarak silinmeyen bir alan ifade etmiyor. Yani belli durumlarda işletim sistemi çok zorlandığında application
sınıfını da silebiliyor. Application sınıfı singleton bir formda bulunmuyor. O yüzden applicationContext'e de süper güvenemezsiniz hiç bir zaman
silinmeyecekmiş gibi güvenemezsiniz çok nadiren olsa da bunlar da silinebiliyor. Activity,fragment ya da herhangi bir x android sınıfına göre
memory'den silinme ihtimali çok daha nadir ama gerçekleşebiliyor.
**Sizin bu custom application sınıfı içerisine yazdığınız her bir entegrasyon sizin uygulamanızın kod launch'ını etkiliyor. Performans açısından
uygulamanın ayağa kaldırılma süresi gibi 3 tane başlatma senaryosu var: cold launch,warm launch,hot launch. Bunlardan cold launch dediğimiz
yöntemde ikona tıklandığında application sınıfından itibaren başlatılan yönteme deniyor. Ve bunun belli bir trash hold'u var o trash hold'un
üzerinde bir başlatma süresi geçiyorsa bu süreyi azaltmak için ilk bakacağımız yerlerden biri application sınıfının onCreate'inde nelerin
initialize edildiği. Yani öyle her sdk sizden application sınıfında initialize olmak istedi diye her sdk'yi de getirip oraya entegre etmeyin.
Ne zaman application sınıfının onCreate'inde kullanmamız gerektiğine nasıl bakıcaz?
Eğer ki o kullanacağınız sdk tüm activity'lerde,fragmentlerden view sınıflarından hepsinden önce gerçekten bir şeylerin kullanılmasını
sağlatacaksa application sınıfında yaparız bunu. Ama sizin mesela sadece dashboard'dan,login register'dan sonra kullandığınız bir sdk var, onun
mesela application sınıfında initialize olmasına gerek yok. Login register akışındaki herhangi bir yerde o sdk'i initialize edebilirsiniz.
Meseka o splash'de bekliyoruz ya bunun sebebi her zaman ilgili uygulamanın kendi backend'i ile haberleştiği için değil arka plandaki kullanılan
3th parti sdk'lerin kendi backend'leriyle iletişiminden ya da arka planda telefonda yaptıkları ekstra işlemlerden kaynaklı da beklemeye neden
olabiliyorsunuz.

field injection kullandığımız yapıların private olmasına izin verilmiyor. Ve inject ettiğimiz sınıfın da constructor'ında inject annotation'ının
bulunması lazım. constructor'ına inject yazdığımız o sınıfın mesela log sınıfının hilt ile injection'a açık olduğunu söylüyoruz. Yani bunu
yaptığınızda hilt kendisinden istenicek bir sınıf olduğunu anlıyor. Dolayısıyla buile işlemi sırasında bunun nesnesinin üretileceğini anlamış
oluyor.

Neden field injection'da by lazy kullanamıyoruz?
çünkü yine de ilk değeri yazmamız gerekiyor nesnenin oluşturulmuş halini bu da var / var ile atama yaparak oluşturmak da tightly coupled. Bu
yüzden lateinit kullanıyoruz nesnesinin nerede üretildiğiyle ilgilenmeyen tek yöntem. @Inject annotation yazmadan kodda bir yerde kullandığımızda
ise bizden initialized olmasını isteyecek. @Inject ile yazdığımızda ise hilt'e şunu demiş oluyoruz; class'ın kendi içerisine boş da olsa inject
constructor koyarak bunu hilt'e bir yerden isteyeceğimizi demiş oluyoruz bunu üretmek zorunda olduğunu hilt bilmiş oluyor. Sonuçta hilt her
class'ın değil bizim belirttiğimiz class'ların nesnelerini üretecek. O yüzden constructor'ında injection olması bu sınıfının nesnesinin hilt
tarafından üretileceğini söylemiş oluyoruz. Sonrasında ne zaman ki lateinit var ile oluşturduğum bir sınıfın nesnesine inject annotation'ununu
verirsem ondan sonra hilt'e bu sınıfın nesnesine ihtiyaç duyacağımı söylemiştim sana önceden işte şimdi ihtiyaç duyuyorum bana o sınıfın nesnesini
ver demiş oluyoruz. Ne zaman ki o lateinit'li nesneye aşağıda bir yerde erişmek istersek o aşamada hilt bize onun nesnesini veriyor. Ve biz o
nesne üzeerinden ilgili nesnein class'ının fonksiyonlarını çağırabiliyoruz.

Mesela bu field injection'ları bir fantezi olarak bir metoda koyup çağırmak istesek hilt bize hata verir,neden?
Çünkü bir metodun içerisindeki değişkenler direk field oluyorlardı set'leri get'leri olmuyordu class member üye olduklarında property olup
bunlara sahip oluyorlardı.

Ben bir class'a değil de ya da class'a inject etmeye çalışıyorum class'ın kendisinde parametre olarak beklediğim yerde (yine o class'a inject
constructor yazdık ama bu sefer parametresi var interface olarak) parametre beklediğim yerde bir interface bekliyorsam. O halde hilt class olsa
ona inject constructor yazar geçerdi ama interface olduğu için object'in expression kullanımında interface gerektiği yerde tek kullanımlık
atılacak nesnesini oluşturup ilgili fonksionlara ilgili yapması gereken işlemleri yaptırdığımız gibi class oluşturup interface'i implemente
edeceğiz (zaten object'in expression kullanımının da arka planda yaptığı şey bu). Peki geri dönüş tipini interface olarak nasıl alabiliyoruz?
Çünkü supertype dediğimiz şeyler bizim hem open ya da abstract class'lar olabilir hem de interface'ler olabilir. Sonuçta siz bir sınıfın
implement ettiği şeyin hangi interface olduğunu söylerseniz o sınıfın nesnesini oluştururken interface olarak geri alabilirsiniz onu supertype'ı
var çünkü. Yani bir sınıfın nesnesini oluşturdunuz tipini belirlerken 3tip yazabilirsiniz: sınıfın kendisini, sınıfın class olarak supertype'ını,
sınıfın supertype olarak interface'ini yazabilirsiniz. Bu durumu da hilt'e söylemek için bu interface'i implemente eden bir sınıfı inject
constructor yapabiliriz. Dolayısıyla bu sınıfın nesnesini oluşturabileceğimizi hilt'e söylemiş olduk. Hilt sadece bu impl sınıfında sen benden bu
sınıfın nesnesini isteyeceksin normalde field injection gibi lateinit var imp: Imp'li bir şey yapsaydık yine ekstra bir şey istemeyecekti çünkü
impl sınıfı da bir sınıf olduğu için inject constructor'ı da kullandığımızdan bir problem olmazdı.Ama biz burda oluşturduğumuz nesneyi class
tipiyle değil interface tipiyle istiyoruz. Bu durumda hilt'e bu sınıfın nesnesini alıcaz ama sınıfın kendi tipi değil supertype'ı tipinde
istiyoruz dememiz gerekiyor. Bunu söylediğimiz yer için de di package açıp hilt module oluşturup abstract class ve bunun module olduğunu hilt'e
anlatmak için module annotaiton'u ve bu module'u nerde kullanacaksak onun component'ini yazdığımız @InstallIn anotation'u. Module'in içerisine
abstrack class olduğu için abstract fun ekliyoruz parametreye imp'i sınıfı veriyoruz geri dönüş tipi olarak da interface'i alacağımızı söylüyoruz.

Peki madem öyle neden interface beklediğimiz yerlere imp sınıfı yazmıyoruz?
Bunun sebebi inversion of control'dür. Çünkü derdimiz şu benim class'ımda bunu kullandığım yerlerde ben her zaman (örnekteki adapter üzerinden
her zaman interface'in fonksiyonunu kullanıyoruz, impl class fonksiyonunu kullanmıyoruz). Bunu yapma sebeplerimizin en büyüklerinden biri yarın
bir gün şöyle bir problem olur: siz mesela kullandığınız analytics tool'u değiştirebilirsiniz, ilerde kesin değişir. Ama işin ana fonksiyonları
bellidir siz sürekli service interface üzerinden fonksiyonu çağırıyorsunuz ama bu fonk arka planda hangi kütüphane ile çalışacak bunu bilmenize
gerek yok. Biz bunu service interface üzerinden yöneterek ve bunun class impl'ınını oluşturarak yarın öbür gün interface'den override ettiğimiz
ilgili fonksiyonun kullanımında Netmera().foo()'yu çağıracaktık mesela şirket başka bir analytic tool'u olan Dataroid'e geçersek Dataroid().foo()
diyeceğiz sadece impl class'a ve işimiz hemen bitecektir. Ne foo() fonk'un çalıştırıldığı 200 satırda değişiklik yaptık ne impl sınıfı içerisinde
toplu bir değişiklik yaptık sadece netmera'daki foo()'nun çalıştırılmasıyla dataroid'de foo()'nun çalıştırılmasında kodları arasında nasıl farklar
var diye buna baktık ve uyguladık. interface foo() fonksiyonumuzda ve ne de onu kullandığımız hiç bir yerde değişiklik yapmadık sadece imp
tarafında değişiklik yapıyoruz arka plandaki bütün işlem değişti ama activity sınıfınızın bundan haberi yok, activity sınıfı hala interface olan
foo()'yu çağırığ işine devam ediyor.

Şimdi de biz bir sınıfı inject etmek istiyorsak ama sınıf bizde değilse bir kütüphanenin içinde yer alıyorsa ama biz onu da tightly couple olarak
sınııfn içerisinde bulundurmamamız lazım. Bizim onu da inject edebiliyor olmamız lazım. Bu gibi bizim sahip olmadığımız başka bir kütüphanenin
sınıfı olan dolayısıyla içerisine girip constructor'ını inject edemediğimiz bir sınıfı da inject edebilmemiz için bir yöntem var. Bunun için de
@Provides dediğimiz bir annotation'unumuz olacak. Şimdi problemimiz şu; bizim bu retrofit nesnesine ihtiyacımız var, projesinin içerisinde
kullanıcaz ama onun class'ının herhangi bir yerine erişemiyorum bile file is read-only. Bu retrofit module oluştururken abastract class
kullanmayıp object kullanacağız. Biz burdaki fonksiyonumuzda retrofit'in nasıl üretileceğini söyledik çünkü başka yolumuz yok. Normalde analytics
module'ündeki fonksiyonumuz arka planda çok temel olarak return analyticsServiceImpl yazıcak fonk body'sine bu sayede impl nesnesini service
interface'i geri vericek şekilde alabilecektik. O yüzden bu detayları arka planda hilt ayarlayabileceği için abstract fun ve class yapmamız
yeterliydi. Şimdi retrofit'te olan probleme baktığımızda retrofit'in nasıl nesnesinin üretileceğiyle ilgili kısmı bir function olarak yazıyoruz ve
geri dönüş tipinde de retrofit'i beklediğimizi söylüyoruz bu kadar. @Provides annotation'u ile hilt bizim o fonksiyonda geri dönüp return
edeceğimiz şeyi istediğimizi anlasın diye yazarız. Dolayısıyla herhangi bir yerde

@Inject
lateinit var retrofit: Retrofit

yazabiliriz.
Şimdi peki neden interface'i module'de yazarken abstract kullanırken retrofit'te object kullanıyoruz?
Çünkü interface'in module'u abstract class func olmadığı durumda implementation detayını da bizim vermemiz lazım ama hilt bunu yapması gereken
yapı burda. O yüzden imp detayı olmayacağı için o fonksiyonun abstract function olması lazım fonksiyonun abstract olabilmesi için de abstract bir
class'da yer alması lazım. Ama networkmodule'deki yapıya baktığımızda nesnenin nasıl oluşturulacağını bizim söylememiz lazım. Bu yüzden de burda
implementation detayını vermemiz lazım o yüzden de fonksiyonu abstract yapamayız fonk'u abstract yapamadığımız düz yazabildiğimiz için de düz
class olarak NetworkModule yazamayız. Çünkü düz class olarak yazsak bu sefer hilt'e module'un nesnesinin nasıl oluşturulacağını söylememiz
gerekir. Bu yüzden object olarak NetworkModule'u tutuyoruz ki ilgili fonksiyona hilt arka planda NetworkModule.provideApiService() diyerek
erişebilsin. @Provides'ın anlamı bu fonksiyonda retrofit nesnesinin dönülmesini sağlatıyor.

** hilt ile ilgili gelebilecek en temel mülakat sorularından biri: Provides ve Binds farkı nedir?
Provides constructor'ı olabilen ama erişemediğimiz kütüphane class'ları için, değiştiremediğimiz kütüphane class'ları için kullanıyoruz. Ve biz
zaten yazdığımız fonksiyonda da o nesnenin nasıl üretildiğini söylüyoruz. Ama Binds'da constructor'ı injection yapamadığımız bir interface'in
implementation'ınını parametre olarak veriyoruz, geri dönüş tipi olarak da o interface'i beklediğimiz durumlarda impl detaylarını yazmıyoruz bu
gibi durumlarda bind'i kullanıyoruz.

** Neden NetworkModule'u abstract class olarak yazmıyoruz içerdeki normal fun olsa bile?

Bazen şöyle dertleriniz olabilecek: Retrofit'i kullanırken biz özellikle bazı durumlarda bu retrofit instance'ının farklı bir versiyonunu
isteyebiliyoruz. Biz yine retrofit instance'ını istiyoruz ama bu retrofit instance'ını isterken, retrofit'lerle kullandığımız interceptor'lar var,
burdaki retrofit instance'ı aynı olucak ama içerde üretim şekli farklı olabilir. Böyle durumlar için de qualifier dediğimiz yapılar var.
Retention annotation içerisinde bu kullanıcağımız annotation'ıun hangi levelde iş yapacağını söylediğimiz bir bilgi.
Şimdi biz qualifier dosyasında aslında kendimiz bir annotation oluşturuyoruz. Mesela kullanıcı uygulamaya girerken belli parametreler token'lar
gerekecek onun için bir de normal kullanım için tokensiz hali olucak. Bu durumda NetworkModule'de iki tane fonksiyonumuz olucak bu api ile ilgili,
ikisi da aynı retrofit nesnesini üretecek ama bir yerde bu instance'ı isterken hangisini verceğini hilt'in söylememiz lazım. Qualifier'lar ile
module seviyesinde ayarlamıştık bunu dolayısıyla çağırdığımız yerde de atıyorum AuthInterceptorRetrofit'i veya diğerini istiyorum diyebilmemiz
lazım. O yüzden field injection ile çağırdığımız yerde şunu inject edeceksin diyoruz.

@AuthInterceptorRetrofit
@Inject
lateinit var retrofit: Retrofit

Dolayısıyla hilt module'de birden fazla varyasyonu olan retrofit nesnelerinden bu qualifier'a sahip olanı istiyor diyoruz.

Predefined Qualifiers : ActivityContext ile ApplicaionContext. Mesela adapter constructor'ında bir context bekliyoruz. Bunlar için hilt'in
içerisinde ön tanımlı olarak bulunan yazılan 2 qualifier'ımız var.

Bilmemiz gerekenler:
1- Biz neden bir dependendy injection tool'u kullanıyoruz? Bunun arkasında yatan sebepler ne?
2- Dependency inversion presibi
3- Inversion of control prensibi
4- tightly couple, losely couple, cohesion kavramları
5- hilt,koin ya da x bir şey kullanmadan biz manuel olarak dependency injection nasıl yapabiliriz?

Bunları bitirdikten sonra hilt özelinde bilinmesi gerekenler:
1- hilt arka planda nasıl çalışıyor? Bu verdiğimiz annotation'lar arka planda napıyor?
2- hilt'in avantajı ne? -> run time safety (hilt kaynaklı bir hatayla karşılaşma ihtimalimiz çok düşük)
3- constructor injection, field injection nedir? Bir sınıfı constructor'dan inject etmem için neye ihtiyacım var?
4- Bir interface'i nasıl inject edebiliriz?
5- Elimizde bir sınıf var constructor'ına inject yapılabilir ama sınıfa erişemiyorsak, bu bir kütüphane sınıfysa nasıl yaparız?
6- Bu üretimini bizim yaptığımız kütüphane sınıfı nesnelerini bazen parametrelerde veya sınıfın üretim şeklinde değişimler olabilir. Aynı değeri
   beklediğimiz böyle değişimlerde nasıl bir yöntem yaparız? -> İkinci fonk yazar hilt'e hangisini istediğimiiz söylemek için qualifier yazıyoruz.
7- Qualifier'lar nasıl kullanılıyor, ne işe yarıyorlar?
8- provide ve bind ne işe yarıyorlar ve farkları?

ViewWithFragmentComponent'i FragmentComponent ve ViewComponent'ten ayıran yapı; bir view'ı kullanıyorsunuz ama o view bir fragment'ın içerisinde
kullanıldığına eminseniz kullanırsınız.

Component lifetime önemli!

Hilt'in temelde 2 görevi var:
1- Size nesneyi vermek
2- Nesnenin lifecycle yönetimini yapmak. Ne kadar süreli olarak kullanacağımız.

Normalde retrofit room gibi yapılar kullandığımızda genelde derdimiz o instance'ı bir kez yaratalım, o instance üzerinden gidelim.
Ne zaman bu singleton'ları kullanıcaz? Eğer ki nesneyi oluşturma işlemi maliyetli bir işlemse singleton, nerdeyse her class'ımda kullanacaksam
ben bunu singleton yapmam lazım çünkü retrofit gibi objeler her ekranda istek atıldığı için singleton ama küçük objeleri singleton yapmamanız
lazım. Bu yüzden hilt'te singleton annotation kullanırken dikkatli olun.

Eğer siz bir adaptar'e @ActivityScoped annotation verirsek bu durumda hilt'in üreteceği instance her çağrıldığı durumda aynı instance'ı döndürür
activity'ler için. Bunu fragment'tan çağırdığımız durumda farklı nesneler oluşturur.